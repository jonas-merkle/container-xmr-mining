name: Docker Build, Publish, and Sign

on:
  push:
    branches:
      - main  # Automatically build on all commits to main
    tags:
      - version-*  # Trigger publish workflow on new version tags
  workflow_dispatch:
    # Allows the workflow to be manually triggered, typically for the develop branch
    inputs:
      branch:
        description: 'Branch to run the workflow on (develop only)'
        required: false
        default: 'develop'
  schedule:
    # Runs monthly at midnight on the first day of the month
    - cron: '0 0 1 * *'

jobs:
  build:
    # Job to build the Docker image
    # Runs on commits to main, tags, or manually triggered for develop branch
    if: github.ref_name == 'main' || startsWith(github.ref, 'refs/tags/') || (github.event_name == 'workflow_dispatch' && github.event.inputs.branch == 'develop')
    runs-on: ubuntu-latest
    steps:
      # Step 1: Install Cosign tool for signing the Docker image
      - name: Install Cosign
        run: |
          curl -LO https://github.com/sigstore/cosign/releases/latest/download/cosign-linux-amd64
          chmod +x cosign-linux-amd64
          sudo mv cosign-linux-amd64 /usr/local/bin/cosign

      # Step 2: Check out the code from the repository
      - name: Checkout repository
        uses: actions/checkout@v2

      # Step 3: Set up Docker Buildx with the docker-container driver for multi-platform support
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2
        with:
          driver-opts: network=host

      # Step 4: Log in to GitHub Container Registry
      # Uses GitHubâ€™s GITHUB_TOKEN for authentication
      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v2
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      # Step 5: Cache Docker layers to speed up subsequent builds
      - name: Cache Docker layers
        uses: actions/cache@v3
        with:
          path: /tmp/.buildx-cache
          key: ${{ runner.os }}-buildx-${{ github.sha }}
          restore-keys: |
            ${{ runner.os }}-buildx-

      # Step 6: Build and cache multi-architecture Docker image (amd64 and arm64)
      - name: Build Docker image
        id: build-and-cache
        uses: docker/build-push-action@v4
        with:
          context: ./src
          file: ./src/Dockerfile
          push: false  # Do not push in build stage
          platforms: linux/amd64,linux/arm64
          tags: ghcr.io/${{ github.repository }}:temp
          cache-from: type=local,src=/tmp/.buildx-cache
          cache-to: type=local,dest=/tmp/.buildx-cache

      # Step 7: Save the built Docker image as an artifact to reuse in the publish job
      - name: Export Docker image as artifact
        run: docker save ghcr.io/${{ github.repository }}:temp | gzip > image.tar.gz
      - name: Upload Docker image artifact
        uses: actions/upload-artifact@v3
        with:
          name: docker-image
          path: image.tar.gz

      # Step 8: Sign the Docker image
      - name: Sign the Docker image
        if: ${{ github.event_name != 'pull_request' }}
        env:
          TAG: ghcr.io/${{ github.repository }}:temp
          DIGEST: ${{ steps.build-and-cache.outputs.digest }}
        run: |
          cosign sign --yes $TAG@$DIGEST

  publish:
    # Job to publish Docker images based on tags or monthly schedule
    needs: build
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && startsWith(github.ref, 'refs/tags/version-') || github.event_name == 'schedule'
    steps:
      # Step 1: Install Cosign tool for signing
      - name: Install Cosign
        run: |
          curl -LO https://github.com/sigstore/cosign/releases/latest/download/cosign-linux-amd64
          chmod +x cosign-linux-amd64
          sudo mv cosign-linux-amd64 /usr/local/bin/cosign

      # Step 2: Check out the code from the repository
      - name: Checkout repository
        uses: actions/checkout@v2

      # Step 3: Download and load the Docker image artifact from the build job
      - name: Download Docker image artifact
        uses: actions/download-artifact@v3
        with:
          name: docker-image
      - name: Load Docker image
        run: docker load -i image.tar.gz

      # Step 4: Extract version from tag if it exists
      - name: Extract version from tag
        if: startsWith(github.ref, 'refs/tags/version-')
        id: version
        run: echo "version=${GITHUB_REF#refs/tags/version-}" >> $GITHUB_ENV

      # Step 5: Log in to GitHub Container Registry
      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v2
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      # Step 6: Tag and push Docker image based on tag or schedule
      - name: Tag and push Docker image
        run: |
          docker tag ghcr.io/${{ github.repository }}:temp ghcr.io/${{ github.repository }}:${{ env.version || 'latest' }}
          docker tag ghcr.io/${{ github.repository }}:temp ghcr.io/${{ github.repository }}:latest
          docker push ghcr.io/${{ github.repository }}:${{ env.version || 'latest' }}
          docker push ghcr.io/${{ github.repository }}:latest

      # Step 7: Sign both the version-specific and latest Docker images
      - name: Sign the published Docker images
        if: ${{ github.event_name != 'pull_request' }}
        env:
          TAGS: |
            ghcr.io/${{ github.repository }}:${{ env.version || 'latest' }}
            ghcr.io/${{ github.repository }}:latest
          DIGEST: ${{ steps.build-and-cache.outputs.digest }}
        run: |
          echo "${TAGS}" | xargs -I {} cosign sign --yes {}@${DIGEST}
