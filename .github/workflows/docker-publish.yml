name: Docker Build, Publish, and Sign

on:
  push:
    branches:
      - main
    tags:
      - version-*
  workflow_dispatch:
    # Allows the workflow to be triggered manually for any branch
    inputs:
      branch:
        description: 'Branch to run the workflow on'
        required: false
        default: 'develop'
  schedule:
    # Runs every day at midnight UTC
    - cron: '0 0 * * *'

jobs:
  build:
    # Job that builds the Docker image
    # Runs on push to main, tags, or manually triggered for develop branch
    if: github.ref_name == 'main' || startsWith(github.ref, 'refs/tags/') || github.event_name == 'workflow_dispatch' && github.event.inputs.branch == 'develop'
    runs-on: ubuntu-latest
    steps:
      # Step 1: Check out the code from the repository
      - name: Checkout repository
        uses: actions/checkout@v2

      # Step 2: Set up Docker Buildx with the docker-container driver for multi-platform support
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2
        with:
          driver-opts: network=host

      # Step 3: Log in to GitHub Container Registry
      # Uses GitHubâ€™s GITHUB_TOKEN for authentication
      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v2
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      # Step 4: Cache Docker layers to speed up subsequent builds
      - name: Cache Docker layers
        uses: actions/cache@v3
        with:
          path: /tmp/.buildx-cache
          key: ${{ runner.os }}-buildx-${{ github.sha }}
          restore-keys: |
            ${{ runner.os }}-buildx-

      # Step 5: Build and export multi-architecture Docker image (amd64 and arm64)
      # Using Docker's build-push-action with cache support
      - name: Build Docker image
        id: build-and-push
        uses: docker/build-push-action@v4
        with:
          context: ./src
          file: ./src/Dockerfile
          push: false  # Do not push to registry in build stage
          platforms: linux/amd64,linux/arm64
          tags: ghcr.io/${{ github.repository }}:temp
          cache-from: type=local,src=/tmp/.buildx-cache
          cache-to: type=local,dest=/tmp/.buildx-cache

      # Step 6: Save the built Docker image as an artifact to reuse in the publish job
      - name: Export Docker image as artifact
        run: docker save ghcr.io/${{ github.repository }}:temp | gzip > image.tar.gz
      - name: Upload Docker image artifact
        uses: actions/upload-artifact@v3
        with:
          name: docker-image
          path: image.tar.gz

      # Step 7: Install Cosign tool for signing the Docker image
      - name: Install Cosign
        run: |
          curl -LO https://github.com/sigstore/cosign/releases/latest/download/cosign-linux-amd64
          chmod +x cosign-linux-amd64
          sudo mv cosign-linux-amd64 /usr/local/bin/cosign

      # Step 8: Sign the published Docker image (skip on pull requests)
      - name: Sign the Docker image
        if: ${{ github.event_name != 'pull_request' }}
        env:
          TAG: ghcr.io/${{ github.repository }}:temp
          DIGEST: ${{ steps.build-and-push.outputs.digest }}
        run: |
          cosign sign --yes $TAG@$DIGEST

  publish:
    # Job that publishes versioned Docker images based on tags (e.g., version-1.0.0)
    # Runs only on pushes that create tags starting with "version-"
    needs: build
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && startsWith(github.ref, 'refs/tags/version-')
    steps:
      # Step 1: Check out the code from the repository
      - name: Checkout repository
        uses: actions/checkout@v2

      # Step 2: Log in to GitHub Container Registry
      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v2
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      # Step 3: Download and load the Docker image artifact from the build job
      - name: Download Docker image artifact
        uses: actions/download-artifact@v3
        with:
          name: docker-image
      - name: Load Docker image
        run: docker load -i image.tar.gz

      # Step 4: Extract version number from the tag (e.g., version-1.0.0 -> 1.0.0)
      # and set it as an environment variable
      - name: Extract version from tag
        id: version
        run: echo "version=${GITHUB_REF#refs/tags/version-}" >> $GITHUB_ENV

      # Step 5: Tag the image with the version and latest tags, then push to registry
      - name: Tag and push Docker image
        run: |
          docker tag ghcr.io/${{ github.repository }}:temp ghcr.io/${{ github.repository }}:${{ env.version }}
          docker tag ghcr.io/${{ github.repository }}:temp ghcr.io/${{ github.repository }}:latest
          docker push ghcr.io/${{ github.repository }}:${{ env.version }}
          docker push ghcr.io/${{ github.repository }}:latest

      # Step 6: Install Cosign tool for signing
      - name: Install Cosign
        run: |
          curl -LO https://github.com/sigstore/cosign/releases/latest/download/cosign-linux-amd64
          chmod +x cosign-linux-amd64
          sudo mv cosign-linux-amd64 /usr/local/bin/cosign

      # Step 7: Sign both the version-specific and latest Docker images
      - name: Sign the published Docker images
        if: ${{ github.event_name != 'pull_request' }}
        env:
          TAGS: |
            ghcr.io/${{ github.repository }}:${{ env.version }}
            ghcr.io/${{ github.repository }}:latest
          DIGEST: ${{ steps.build-and-push.outputs.digest }}
        run: |
          echo "${TAGS}" | xargs -I {} cosign sign --yes {}@${DIGEST}
